<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Model Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: transparent; }
    canvas { display: block; width: 80vw; height: 100vh; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // alpha: true로 설정하여 투명 배경 활성화
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x00000000, 0); // 배경색을 투명으로 설정
    renderer.shadowMap.enabled = true; // 그림자 활성화
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 부드러운 그림자 사용

    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
    // Ambient Light 설정 (모든 방향에서 오는 부드러운 빛, 모델 전체를 밝게 함)
    const ambientLight = new THREE.AmbientLight(0xE3E3E3, 0.2);
    scene.add(ambientLight);

    // Directional Light 설정 (햇빛처럼 특정 방향에서 오는 빛)
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(10, 20, 10); // 모델을 위에서 비추는 방향으로 위치 조정
    directionalLight.castShadow = true; // 그림자 활성화
    directionalLight.shadow.mapSize.width = 2048; // 그림자 품질 개선
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    // 바닥이 없이 공중에 그림자를 드리우도록 설정
    const shadowPlaneGeometry = new THREE.PlaneGeometry(200, 200);
    const shadowPlaneMaterial = new THREE.ShadowMaterial({ opacity: 0.3 }); // 그림자만 보이도록 설정
    const shadowPlane = new THREE.Mesh(shadowPlaneGeometry, shadowPlaneMaterial);
    shadowPlane.rotation.x = -Math.PI / 2;
    shadowPlane.position.y = -10; // 모델 아래쪽에 그림자 투영용 평면 설정
    shadowPlane.receiveShadow = true; // 그림자 받기 활성화
    scene.add(shadowPlane);

    const loader = new THREE.GLTFLoader();
    loader.load(
      'file:///android_asset/ttubeotModels/ghostModel.glb',
      (gltf) => {
        const model = gltf.scene;

        // 모델 크기 조정
        model.scale.set(2, 2, 2);
        model.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true; // 모델의 모든 Mesh가 그림자를 만들도록 설정
            node.receiveShadow = true; // 필요 시 모델 자체도 그림자를 받을 수 있도록 설정
          }
        });
        
        scene.add(model);

        // 카메라 위치를 모델 주변으로 조정
        camera.position.set(0, 360, 0); // Y 위치를 약간 높여 모델이 잘 보이게 함(나중에 카메라 위치 에셋에 맞게 수정)
        camera.lookAt(model.position); // 모델을 바라보도록 설정

        const animate = () => {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
        };
        animate();
      },
      undefined,
      (error) => {
        const errorDetails = JSON.stringify(error, Object.getOwnPropertyNames(error));
        window.ReactNativeWebView.postMessage(`An error occurred loading the GLB model: ${errorDetails}`);
      }
    );
  </script>
</body>
</html>
